#!/usr/bin/python3

import string
from itertools import product
import random
import argparse
import json
import os

SKELETON="""
#!/bin/bash

# This was auto-generated by autoscript.

{} \\
{}

"""

def enumerate_dict(inp):
    # # https://stackoverflow.com/questions/5228158/cartesian-product-of-a-dictionary-of-lists
    return (dict(zip(inp.keys(), values)) for values in product(*inp.values()))

def parse_args():
    parser = argparse.ArgumentParser("")
    parser.add_argument("--chunk", type=int, default=1,
                        help="""If this is > 1, then group
                        experiments by that many chunks. For instance,
                        if we had 10 HP configs and `--chunk=2`, then
                        five of those would go into e.g. `exps/<name>/c1`
                        and the other five into `exps/<name>/c2`. The
                        purpose of this feature is to facilitate
                        economical use of GPUs by easily running each
                        chunk on just one GPU, if required.
                        """)
    parser.add_argument('--out_dir', type=str, default="exps")
    parser.add_argument('--json', required=True)
    parser.add_argument('--dry_run', action='store_true',
                        help="""If true, do not produce any
                        files -- just simulate the output/
                        """)

    args = parser.parse_args()
    return args

args = parse_args()

#cmd = "\n".join(cmd)
#flags = " \\ \n".join([(str(a) + " " + str(b)) for a,b in zip(elem.keys(), elem.values())])

dd = json.loads(open(args.json).read())

experiment_name = dd['metadata']['name']
if dd['metadata']['random_id']:
    experiment_name += ("-" + "".join([ random.choice(string.ascii_letters[0:26]) for j in range(5) ]))
print(experiment_name)

cmd = dd['cmd']

cfgs = [elem for elem in enumerate_dict(dd['parameters'])]
print("How many HP cfgs generated: %i" % len(cfgs))

idx2chunk = []
if args.chunk > 0:
    for idx, k in enumerate(range(0, len(cfgs), args.chunk)):
        #print(k, k+args.chunk, idx)
        # Map [k, k+args.chunk] to idx
        for z in range(k, k+args.chunk):
            idx2chunk.append(idx)
print("idx2chunk:", idx2chunk)


for idx, elem in enumerate(cfgs):
    filename = "id%i_chunk%i.sh" % (idx, idx2chunk[idx])
    out_file = "%s/%s/%s" % (args.out_dir, experiment_name, filename)
    flags = " \\ \n".join([(str(a) + " " + str(b)) for a,b in \
                           zip(elem.keys(), elem.values())])
    print("out file :", out_file)
    if not args.dry_run:
        if not os.path.exists(os.path.dirname(out_file)):
            os.makedirs(os.path.dirname(out_file))
        with open(out_file, "w") as f:
            f.write(SKELETON.format(cmd, flags) + "\n")
